import re

'''


'.' 匹配任意字符
    （点号。）在默认模式下，匹配除换行以外的任意字符.如果 DOTALL 标志被指定, 则匹配包括换行符在内的所有字符.
'^' 匹配开头
    （脱字符号。）在默认模式下匹配字符串的起始位置, 在MULTILINE模式下也匹配换行符之后的位置.
'$' 匹配结尾
    匹配字符串的末尾或者字符串末尾换行符之前的位置，在MULTILINE模式下还匹配换行符之前的位置
'*' 匹配*前面的字符0次到多次, 匹配次数为0也可以
    匹配前面重复出现的正则表达式零次或多次，尽可能多的匹配。ab*将匹配‘a’、‘ab’或‘a’ 后面跟随任意数目的‘b’。
'+' 匹配+前面的字符1次到多次, 匹配次数为0不可以
    引起生成的RE匹配1个或多个前导的RE，尽可能多的匹配。ab+将匹配‘a’之后跟随任意多个数目不为零的‘b’，它将不能匹配单纯的一个‘a’。

'?' 匹配前面的0个或1个
    引起生成的RE匹配0个或1个前导的RE。ab?将匹配‘a’或者‘ab’。
    
'*?', '+?', '??'
    '*'、'+'和'?'限定符是'贪婪的'；它们匹配尽可能多的文本。有时这个行为不是想要的；
    如果用正则表达式<.*>来匹配'<H1>title</H1>'，它将匹配完整的字符串，而不会只是'<H1>'。
    在限定符之后加上'?'将使得匹配以非贪婪的或最小的方式进行；因为它将匹配尽可能少的字符。
    在刚才的表达式中使用.*?将只匹配'<H1>'。
    

{m}
    表示精确匹配前面的正则表达式的m个拷贝；较少的匹配将导致整个表达式不能匹配。例如，a{6}将精确匹配6个'a'字符，5个将不能匹配。
{m,n}
    引起生成的正则表达式匹配前导正则表达式的m到n个重复，尝试匹配尽可能多的重复。例如，a{3,5}将匹配3到5个'a'字符。省略m表示下界为0，省略n表示上界无限大。举个例子，a{4,}b将匹配aaaab或一千个'a'字符后跟随一个b，但不能匹配aaab。
    逗号不可以省略，否则该修改符将与前面的形式混淆。

{m,n}? 非贪婪模式，匹配最少的
    例如，对于6个字符的字符串'aaaaaa'，a{3,5}将匹配5个'a'字符，而a{3,5}?将只匹配3个字符。

'\'
    对任一特殊字符进行转义（允许您匹配字符（如'*'，' ? '，等等），或只是一个特殊的序列；特殊序列在下面讨论。
    如果你不使用原始字符串来表达模式，记住在字符串字面值中Python也使用反斜杠作为转义序列；
    如果转义序列不能被Python解析器识别，那么结果字符串中包含反斜杠和后面的字符。
    但是，如果Python会识别所产生的序列，反斜杠应该重复两次。
    这比较复杂和难以理解，因此强烈建议你为所有即使是最简单的表达式使用原始字符串。
    
[]
    用来表示一个字符集合。在一个集合中：
    1.字符可以一个一个列出来，例如[amk]将匹配'a'、'm'或'k'。
    2.通过给出两个字符并用'-'分隔，可以给出一段范围的字符，例如[a-z]将匹配任意一个小写的ASCII字符，[0-5][0-9]将匹配00到59之间所有的两位数字，[0-9A-Fa-f]将匹配任意一个十六进制数字。如果-被转义（例如[a\-z]）或者如果它位于第一个或最后一个字符（例如[a-]），它将只匹配一个字面值'-'。
    3.在集合内部，特殊字数将失去它们特殊的含义。例如，[(+*)]将匹配字符字面值'('、'+'、'*'或')'。
    4.在集合中还接受字符类别，例如\w或\S（在下文定义），尽管它们匹配的字符取决于LOCALE或UNICODE模式是否是强制的。
    5.不在一段范围之内的字符可以通过补集匹配。如果集合的第一个字符是'^'，那么所有不在集合中的字符都将被匹配。例如，[^5]将匹配除'5'之外的所有字符，[^^]将匹配除'^'之外的所有字符。^如果不是集合中的第一个字符则没有特殊的含义。
    6.若要匹配集合中的一个字符字面值']'，可以在它前面放一个反斜线或者将它放在集合的开始。例如，[()[\]{}]和[]()[{}]都将匹配一个圆括号。
    

'''

